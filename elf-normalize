#!/usr/bin/python3

from tempfile import mktemp
import os, sys
import math
from scipy.io import wavfile
import matplotlib.pyplot as plt
import numpy as np

# Create temporary WAV file, and read data from it
tname = mktemp() + ".wav"
os.system("ffmpeg -i " + sys.argv[1] + " " + tname)
samplingRate, data = wavfile.read(tname)
os.unlink(tname)

print(samplingRate)
print(data)

# Get information about the number type used to represent the samples
numInfo = np.iinfo(data.dtype)
sampleMax = numInfo.max
sampleMin = numInfo.min

if numInfo.min == 0:
    print("We only accept samples encoded in signed integers")
    sys.exit(1)

def is_normalized(data):
    data = (sampleMax - np.abs(data)) / sampleMax

    if (data > 0.2).all():
        return False
    else:
        return True

print(is_normalized(data))

plt.figure()
plt.plot(data[:,0])
plt.show()

#totalSecs = wfile.getnframes() / wfile.getframerate()
#secs, mins = math.modf(totalSecs / 60) # separates fractional and integer parts
#mins = int(mins)
#secs = math.floor(60 * secs)

#print("Length: {}m {}s".format(mins, secs))

sys.exit()

if wfile.getnchannels() == 2:
    totalFrames = wfile.getnframes()

    channelR = []
    channelL = []

    for i in range(totalFrames):
        data = wfile.readframes(1)
        data = struct.unpack("<2h", data) # Unpack as 2-byte 2s-complement numbers
        channelR.append(int(data[0]))
        channelL.append(int(data[1]))

    plt.figure()
    plt.hist(channelR[0:10000])
    plt.show()
else:
    print("Cannot normalize mono music yet.")


# wfile.close()
# os.unlink(tname)
