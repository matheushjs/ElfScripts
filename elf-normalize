#!/usr/bin/python3

import os, sys
import matplotlib.pyplot as plt
import numpy as np

# Refer to https://github.com/jiaaro/pydub/blob/master/API.markdown for the API documentation
from pydub import AudioSegment

usageStr = \
"""
Usage: ./{} [--rms=-17] input_file

Options:
    -h                Displays this help message.
    --rms [float]     The RMS level (in dB) to which we should normalize the song.
""".format(sys.argv[0])

# Stores arguments passed via comman line
cmdArgs = dict()

if "-h" in sys.argv:
    print(usageStr)
    sys.exit(0)

for (cmd, TYP) in [
                    ("--rms", int)
                    ]:
    if cmd in sys.argv:
        try:
            idx = sys.argv.index("--rms")
            val = TYP(sys.argv[idx + 1])
            sys.argv.pop(idx+1)
            sys.argv.pop(idx)
            cmdArgs[cmd] = val
        except Exception as e:
            print("Error parsing argument {} : {}!".format(cmd, e))
            sys.exit(1)

# Read the file
audio = AudioSegment.from_mp3(sys.argv[1])
print("Frame rate:", audio.frame_rate)

# Refer to https://en.wikipedia.org/wiki/DBFS (DeciBels relative to Full Scale)
# Also see https://en.wikipedia.org/wiki/Decibel for the formula
# 10*log10(P / P_0) where P_0 is the reference value (max power)
# 20*log10(A / A_0) where A_0 is the max amplitude (see the source code of pydub)
print("Max dBFS:", audio.max_dBFS)

# Get the due numpy array
samples = np.frombuffer(audio.raw_data, dtype=np.int16)
nSamples = samples.shape[0]

# We assume 2 channels, and reshape the array to 2 columns
samples = samples.reshape(nSamples//2, 2, order="C")

def is_normalized(audio):
    fraction = audio.max / audio.max_possible_amplitude

    if fraction < 0.9:
        return False
    else:
        return True

# Square root of the mean of the square of each sample https://en.wikipedia.org/wiki/Root_mean_square
def get_rms(samples):
    powers = np.power(samples, 2, dtype=np.float64)

    if np.sum(powers < 0) > 0:
        print("Numeric overflow detected.")
        sys.exit(1)

    return np.sqrt(np.mean(powers))

def to_db(value, maxValue):
    return 20 * np.log10(value / maxValue)

def from_db(valueDb, maxValue):
    return np.power(10, valueDb/20) * maxValue

# We use the property RMS(a*X) = sqrt(a)*RMS(X)
def get_rms_normalization_factor(rmsValue, maxValue, normLevelDb=-17):
    normLevel = from_db(normLevelDb, maxValue)
    return (normLevel / rmsValue)**2


print("Normalized:", is_normalized(audio))

rms = get_rms(samples)
print("RMS:", to_db(rms, audio.max_possible_amplitude), "dB")

factor = get_rms_normalization_factor(rms, audio.max_possible_amplitude)
print("Gain: {:.3f} x".format(float(factor)))

# In the original audio, samples large than 'clippingBound' will be clipped
clippingBound = audio.max_possible_amplitude / factor
normalized = samples.copy()
idx = np.where(np.abs(normalized) > clippingBound)

if len(idx) > 0:
    print("Samples_Clipped: {} ({:.3f}%)".format(len(idx), len(idx) / len(samples) * 100))

# If we don't do this, the gain will cause numeric overflow in numpy * operator
normalized[idx] = clippingBound
normalized = normalized * factor

normalizedMax = max(normalized.max(), -normalized.min())
diff = abs(audio.max - normalizedMax)
gainDb = to_db(diff, audio.max_possible_amplitude)
print("Gain(dB):", gainDb)

print("New_Maximum_dBFS:", to_db(np.max(np.abs(normalized)), audio.max_possible_amplitude), "dB")
print("New_RMS:", to_db(get_rms(normalized), audio.max_possible_amplitude), "dB")

plt.figure(dpi=150)
plt.title("Changes made to the song (just a fraction of the song)")
if factor < 1:
    plt.plot(samples[:100000,0], c="blue", label="Old")
    plt.plot(normalized[:100000,0], c="red", label="New")
else:
    plt.plot(normalized[:100000,0], c="red", label="New")
    plt.plot(samples[:100000,0], c="blue", label="Old")

plt.legend()
plt.show()

# The procedures below DO NOT preserve metadata!
#audio.normalize(0)
#audio.export("output.mp3", format="mp3")

# plt.figure()
# plt.plot(samples[:,0])
# plt.show()
