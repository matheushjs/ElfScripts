#!/usr/bin/python3

import os, sys
import matplotlib.pyplot as plt
import numpy as np

# Refer to https://github.com/jiaaro/pydub/blob/master/API.markdown for the API documentation
from pydub import AudioSegment

usageStr = \
"""
Usage: ./{} [--rms=17] input_file

Options:
    -h                Displays this help message.
    --rms [integer]   The RMS level (in dB) to which we should normalize the song.
""".format(sys.argv[0])

# Stores arguments passed via comman line
cmdArgs = dict()

if "-h" in sys.argv:
    print(usageStr)
    sys.exit(0)

for (cmd, TYP) in [
                    ("--rms", int)
                    ]:
    if cmd in sys.argv:
        try:
            idx = sys.argv.index("--rms")
            val = TYP(sys.argv[idx + 1])
            sys.argv.pop(idx+1)
            sys.argv.pop(idx)
            cmdArgs[cmd] = val
        except Exception as e:
            print("Error parsing argument {} : {}!".format(cmd, e))
            sys.exit(1)

# Read the file
audio = AudioSegment.from_mp3(sys.argv[1])
print("Frame rate:", audio.frame_rate)

# Refer to https://en.wikipedia.org/wiki/DBFS (DeciBels relative to Full Scale)
# Also see https://en.wikipedia.org/wiki/Decibel for the formula
# 10*log10(P / P_0) where P_0 is the reference value (max power)
# 20*log10(A / A_0) where A_0 is the max amplitude (see the source code of pydub)
print("Max dBFS:", audio.max_dBFS)

# Get the due numpy array
samples = np.frombuffer(audio.raw_data, dtype=np.int16)
nSamples = samples.shape[0]

# We assume 2 channels, and reshape the array to 2 columns
samples = samples.reshape(nSamples//2, 2, order="C")

def is_normalized(audio):
    fraction = audio.max / audio.max_possible_amplitude

    if fraction < 0.9:
        return False
    else:
        return True

# Square root of the mean of the square of each sample https://en.wikipedia.org/wiki/Root_mean_square
def rms(samples):
    powers = np.power(samples, 2, dtype=np.float64)

    if np.sum(powers < 0) > 0:
        print("Numeric overflow detected.")
        sys.exit(1)

    return np.sqrt(np.mean(powers))

# TODO: Calculate rms in decibels

# TODO: Calculate the gain needed to achieve a certain RMS level

print(sys.argv)
print("Normalized:", is_normalized(audio))
print("RMS:", rms(samples))

print(cmdArgs)

# The procedures below DO NOT preserve metadata!
#audio.normalize(0)
#audio.export("output.mp3", format="mp3")

# plt.figure()
# plt.plot(samples[:,0])
# plt.show()
